let grid = [], cellW, cellH, rock;
let rows = 4;
let cols = 4;
let bg, fg, alt, hlt;

function preload() {
  //rock = loadImage('/assets/rock.gif');
  rock = loadImage('https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/U.S._hundred_dollar_bill%2C_1999.jpg/640px-U.S._hundred_dollar_bill%2C_1999.jpg');
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  bg = color(33, 33, 33);
  fg = color(22, 233, 33);
  alt = color(233, 133, 22);
  hlt = color(233, 33, 22);
  rectMode(CENTER);
  rock.filter(INVERT);
}

function draw() {
  background(bg);
  createGrid();
  drawImgs();
  drawGridVecs();
  drawDistBtwnVecs();
}

// Create the structure of the grid dependent on canvas dimensions and number of columns & rows
function createGrid() {
  grid = [];
  cellW = width / cols;
  cellH = height / rows;
  // Populate grid with vectors
  for (let i = 0; i <= rows; i++) {
    let row = [];
    for (let j = 0; j <= cols; j++) {
      let x = j * cellW;
      let y = i * cellH;
      row.push(new vectorObjs(x, y));
    }
    grid.push(row);
  }
}

// Display the corners and points of intersections of the grid
function drawGridVecs() {
  // Represent each vector as a rectangle
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
      let v = grid[i][j];
      noFill();
      stroke(fg);
      rect(v.x, v.y, 15, 15);
    }
  }
}

// Display the distance between each vector and it's neighbouring vector/s
// that are directly above, below, to it's left, to it's right
// Function to display the distance between each vector and its neighboring vectors
function drawDistBtwnVecs() {
  // Loop through each row in the grid
  for (let i = 0; i < grid.length; i++) {
    // Loop through each column in the current row
    for (let j = 0; j < grid[i].length; j++) {
      // Get the current vector
      let v = grid[i][j];
      let distAbove, distBelow, distLeft, distRight;
      stroke(fg);

      // Check if there is a vector above the current vector
      if (i > 0) {
        // Get the vector above the current vector
        let above = grid[i-1][j];
        // Calculate the distance between the current vector and the vector above
        let distAbove = dist(v.x, v.y, above.x, above.y);
        // Display the distance at the midpoint between the current vector and the vector above
        fill('red');
        noStroke();
        text(distAbove.toFixed(2), (v.x + above.x) / 2, (v.y + above.y) / 2);
        stroke(fg);
        line(v.x, v.y, above.x, above.y);
      }

      // Check if there is a vector below the current vector
      if (i < grid.length - 1) {
        // Get the vector below the current vector
        let below = grid[i+1][j];
        // Calculate the distance between the current vector and the vector below
        let distBelow = dist(v.x, v.y, below.x, below.y);
        // Display the distance at the midpoint between the current vector and the vector below
        fill('blue');
        noStroke();
        text(distBelow.toFixed(2), (v.x + below.x) / 2, (v.y + below.y) / 2);
        stroke(fg);
        line(v.x, v.y, below.x, below.y);
      }

      // Check if there is a vector to the left of the current vector
      if (j > 0) {
        // Get the vector to the left of the current vector
        let left = grid[i][j-1];
        // Calculate the distance between the current vector and the vector to the left
        let distLeft = dist(v.x, v.y, left.x, left.y);
        // Display the distance at the midpoint between the current vector and the vector to the left
        fill(fg);
        noStroke();
        text(distLeft.toFixed(2), (v.x + left.x) / 2, (v.y + left.y) / 2);
        stroke(fg);
        line(v.x, v.y, left.x, left.y);
      }

      // Check if there is a vector to the right of the current vector
      if (j < grid[i].length - 1) {
        // Get the vector to the right of the current vector
        let right = grid[i][j+1];
        // Calculate the distance between the current vector and the vector to the right
        let distRight = dist(v.x, v.y, right.x, right.y);
        // Display the distance at the midpoint between the current vector and the vector to the right
        fill('yellow');
        noStroke();
        text(distRight.toFixed(2), (v.x + right.x) / 2, (v.y + right.y) / 2);
        stroke(fg);
        line(v.x, v.y, right.x, right.y);
      }
    }
  }
}

function drawImgs() {
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
      let v = grid[i][j];

      // Calculate width (horizontal distance to the next vector in the same row)
      let imgWidth = 0;
      if (j < grid[i].length - 1) {
        let vNext = grid[i][j + 1];  // The vector to the right
        imgWidth = dist(v.x, v.y, vNext.x, vNext.y);  // Horizontal distance
      }

      // Calculate height (vertical distance to the next vector in the same column)
      let imgHeight = 0;
      if (i < grid.length - 1) {
        let vBelow = grid[i + 1][j];  // The vector below
        imgHeight = dist(v.x, v.y, vBelow.x, vBelow.y);  // Vertical distance
      }

      // Only draw the image if both width and height are greater than 0
      if (imgWidth > 0 && imgHeight > 0) {
        // Center the image at the vector position by offsetting half the size
        image(rock, v.x, v.y, imgWidth, imgHeight);
      }
    }
  }
}


function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
